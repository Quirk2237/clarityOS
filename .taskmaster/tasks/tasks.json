{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Update Database Schema for Brand Information",
        "description": "Add 'brand_name' and 'brand_description' columns to the 'profiles' table in Supabase. This will store the essential brand information collected during the new onboarding flow.",
        "details": "Create a new SQL migration script. The script should contain the following commands: `ALTER TABLE public.profiles ADD COLUMN brand_name TEXT;` and `ALTER TABLE public.profiles ADD COLUMN brand_description TEXT;`. Additionally, review and update the Row Level Security (RLS) policies on the `profiles` table to ensure users can only read and write their own brand information. The existing policy for updates should cover this, but it's crucial to verify.",
        "testStrategy": "Run the migration script in a development environment. Connect to the Supabase database and verify that the `profiles` table contains the `brand_name` and `brand_description` columns. Test RLS by authenticating as a user and attempting to update another user's profile data via an API call; the request should be denied.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create SQL Migration Script",
            "description": "Create and apply SQL migration to add brand_name and brand_description columns to profiles table",
            "details": "Create new migration file in supabase/migrations/ with ALTER TABLE statement to add brand_name VARCHAR(255) and brand_description TEXT columns to profiles table, apply migration to database",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 1
          },
          {
            "id": 2,
            "title": "Verify and Update RLS Policies",
            "description": "Review and update Row Level Security policies to ensure proper access control for new brand fields",
            "details": "Review existing RLS policies on profiles table, ensure users can read/write their own brand information, test policy enforcement, update policies if needed for brand fields",
            "status": "done",
            "dependencies": [
              "1.1"
            ],
            "parentTaskId": 1
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement API Endpoint for Updating Brand Profile",
        "description": "Create a backend mechanism to securely update the newly added brand fields for an authenticated user. This will be called from the new onboarding screen.",
        "details": "Leverage the Supabase auto-generated API for the `profiles` table. The frontend will make a `PATCH` request to update the user's record. The call will look like: `const { data, error } = await supabase.from('profiles').update({ brand_name: '...', brand_description: '...' }).eq('id', user.id).select()`. No custom Edge Function is necessary unless additional server-side validation beyond RLS is required.",
        "testStrategy": "Use a REST client like Postman or Insomnia to make a `PATCH` request to the `/rest/v1/profiles` endpoint with a valid user's JWT. Provide a request body with `brand_name` and `brand_description`. Verify that the database record is updated and the API returns a 200 OK response. Test failure cases, such as requests with an invalid or missing JWT.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Build Brand Onboarding UI Screen",
        "description": "Develop a new, responsive React Native screen component for the brand onboarding form. This screen will be presented to new users after the welcome screen.",
        "details": "Create a new file, e.g., `BrandOnboardingScreen.js`. The component should use the existing design system for consistency. It will include a title, two `TextInput` components for 'Brand Name' and 'Brand Description', and a 'Continue' button. Implement `SafeAreaView` from `react-native-safe-area-context` for proper layout on all mobile devices. Ensure all interactive elements are accessible with appropriate labels.",
        "testStrategy": "Render the component in a standalone view or using Storybook. Verify the layout is responsive and looks correct on various screen sizes for both iOS and Android. Check that keyboard avoidance is handled correctly when inputs are focused. Run an accessibility linter to check for compliance.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Basic Component Structure",
            "description": "Create the basic React Native component with SafeAreaView, TextInput fields for brand name and description, and submit button",
            "details": "Create new file app/onboarding.tsx with basic structure including SafeAreaView wrapper, brand name TextInput, brand description TextArea, and submit Button following existing design patterns",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 3
          },
          {
            "id": 2,
            "title": "Apply Design System Styling and Responsiveness",
            "description": "Apply consistent styling from the design system and ensure responsive layout works on both iOS and Android",
            "details": "Use existing UI components from components/ui, apply proper spacing and typography, implement responsive design using Flexbox, test on both iOS and Android simulators",
            "status": "done",
            "dependencies": [
              "3.1"
            ],
            "parentTaskId": 3
          },
          {
            "id": 3,
            "title": "Implement Accessibility Features",
            "description": "Add accessibility labels, hints, keyboard navigation support, and screen reader compatibility",
            "details": "Add accessibilityLabel and accessibilityHint props to form elements, implement proper tab order, add keyboard avoidance for form inputs, test with screen reader",
            "status": "done",
            "dependencies": [
              "3.2"
            ],
            "parentTaskId": 3
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement Onboarding Form Logic and API Submission",
        "description": "Integrate form state management, validation, and the API call into the Brand Onboarding screen. This task makes the UI functional.",
        "details": "Use a library like `react-hook-form` to manage form state and validation. Both `brand_name` and `brand_description` fields must be required. On button press, `handleSubmit` will trigger validation. If successful, it will call the Supabase update function from Task 2. Implement loading and disabled states for the button during the API call. Display clear, user-friendly error messages for both validation failures and API errors.",
        "testStrategy": "Unit test the validation rules. Manually test the complete form flow: 1) Try to submit with empty fields and verify error messages appear. 2) Fill the form and submit; verify a loading indicator shows and the user is navigated away on success. 3) Mock an API error and verify a user-friendly error message is displayed.",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrate Form State Management",
            "description": "Set up react-hook-form or similar form library to manage input field state and form submission",
            "details": "Install and configure react-hook-form, create form schema with useForm hook, bind form inputs to state management, implement form reset functionality",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 4
          },
          {
            "id": 2,
            "title": "Implement Form Validation Rules",
            "description": "Add validation rules for required fields and implement real-time validation feedback",
            "details": "Create validation schema with required field validation for brand name and description, implement error message display, add real-time validation feedback during typing",
            "status": "done",
            "dependencies": [
              "4.1"
            ],
            "parentTaskId": 4
          },
          {
            "id": 3,
            "title": "Create API Submission Handler",
            "description": "Implement the onSubmit handler that calls Supabase to update user profile with brand information",
            "details": "Create async onSubmit function that calls Supabase client to update profiles table, handle API response and errors, implement proper error logging and user feedback",
            "status": "done",
            "dependencies": [
              "4.2"
            ],
            "parentTaskId": 4
          },
          {
            "id": 4,
            "title": "Implement UI Feedback States",
            "description": "Add loading states, success feedback, and error handling UI components",
            "details": "Implement loading spinner during form submission, show success message on completion, display error messages for failed submissions, disable form during loading state",
            "status": "done",
            "dependencies": [
              "4.3"
            ],
            "parentTaskId": 4
          }
        ]
      },
      {
        "id": 5,
        "title": "Update Navigation Flow with Onboarding Logic",
        "description": "Update the application's navigation logic to conditionally show the onboarding screen. New users will be directed to it, while existing users with brand data will skip it.",
        "details": "Using the Expo routing system, modify the initial navigator for authenticated users. After a user logs in, fetch their profile from Supabase. Check if `profile.brand_name` is null or an empty string. If it is, use `router.replace('/onboarding')` to navigate to the onboarding screen. Otherwise, use `router.replace('/dashboard')` to proceed to the main dashboard.",
        "testStrategy": "Test with two user accounts. User A: A new user with no brand data in the database; verify they are redirected to the onboarding screen after login. User B: An existing user with `brand_name` populated; verify they are redirected directly to the dashboard, bypassing the onboarding screen.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Profile Fetch Logic",
            "description": "Add logic to fetch user profile data immediately after login to check for brand information",
            "details": "Create function to fetch user profile from Supabase after authentication, check if brand_name and brand_description exist, implement loading state during profile fetch",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 2,
            "title": "Add Conditional Navigation Logic",
            "description": "Update root navigator to conditionally route users to onboarding or dashboard based on profile data",
            "details": "Modify app/_layout.tsx to check profile data after authentication, route new users to onboarding screen if brand info is missing, route existing users directly to dashboard if brand info exists",
            "status": "done",
            "dependencies": [
              "5.1"
            ],
            "parentTaskId": 5
          }
        ]
      },
      {
        "id": 6,
        "title": "Integrate Brand Context into AI Prompts",
        "description": "Modify the existing AI prompt infrastructure to include the user's brand name and description in all AI-related API calls.",
        "details": "Create a centralized hook, e.g., `useAIContext()`, that retrieves the user's profile (ideally from a global state/context to avoid re-fetching). This hook will return the `brand_name` and `brand_description`. Refactor all AI service call sites to use this hook. The brand information should be prepended to the prompt as system-level context, for example: `System: The user's brand is '${brand_name}'. It is described as: '${brand_description}'.\\n\\nUser: ${user_prompt}`.",
        "testStrategy": "In a development environment, monitor the network requests being sent to the AI service. Confirm that the payload for each request now includes the brand context. Manually test several guided discovery sections and verify that the AI's responses are more personalized and relevant to the test user's brand.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Centralize User Profile State Management",
        "description": "Implement a global state management solution to store the user's profile, including brand info, to prevent redundant API calls across the app.",
        "details": "Use a lightweight state management library like Zustand or React's built-in Context API. Create a `ProfileProvider` or `profileStore` that fetches the user's profile upon login and makes it available globally. The navigation logic (Task 5) and the AI context hook (Task 6) should be refactored to read from this store instead of fetching data directly. When the user completes onboarding, the store should be updated with the new brand info to ensure UI consistency.",
        "testStrategy": "Using React DevTools, inspect the global state to confirm the profile is loaded once on login. Navigate between screens that use profile data and verify no new network requests for the profile are made. After completing onboarding, confirm the global state is updated immediately without a page reload.",
        "priority": "medium",
        "dependencies": [
          5,
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set Up State Management Library and Initialize `profileStore`",
            "description": "Install the chosen state management library (e.g., Zustand, Redux Toolkit) and create the initial `profileStore` file with a basic structure and type definitions for the profile data.",
            "dependencies": [],
            "details": "Choose and install the state management library. Create a new file for the store, such as `src/stores/profileStore.ts`. Define the state interface, including properties for the user profile, loading status, and potential errors. Initialize the store with default values.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Profile Fetch and Update Logic in `profileStore`",
            "description": "Add asynchronous actions to the `profileStore` to fetch the user's profile data from the backend upon login and implement actions to handle profile updates and logout.",
            "dependencies": [
              1
            ],
            "details": "Create an async action `fetchProfile` that makes an API call to the user profile endpoint, handling loading, success, and error states. Create an `updateProfile` action to send data to the backend and update the state. Implement a `clearProfile` action to reset the store on logout.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Refactor Navigation Logic to Use `profileStore`",
            "description": "Modify the application's navigation logic (from Task 5) to subscribe to the `profileStore` and use the profile data to control routing and display user-specific navigation elements.",
            "dependencies": [
              2
            ],
            "details": "Identify all components and hooks related to navigation that currently manage profile state. Replace local state management with hooks to access the `profileStore`. Ensure navigation guards and conditional rendering logic read profile status from the central store.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Refactor `useAIContext` Hook to Use `profileStore`",
            "description": "Update the `useAIContext` hook (from Task 6) to source user profile information directly from the `profileStore` instead of fetching it independently or receiving it via props.",
            "dependencies": [
              2
            ],
            "details": "Locate the `useAIContext` hook and remove any internal logic for fetching the user profile. Integrate the state management library's hook to connect to the `profileStore`. Pull necessary profile data (e.g., user ID, preferences) from the store to configure the AI context.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "End-to-End Testing and Final Polish",
        "description": "Conduct a full end-to-end test of the entire onboarding flow and perform a final polish of the UI and accessibility features.",
        "details": "Execute a comprehensive test plan covering all acceptance criteria. This includes the new user path through onboarding and the existing user path that bypasses it. Test on both iOS and Android physical devices or simulators. Check for responsiveness, loading states, error handling, and overall flow smoothness. Use accessibility inspector tools to identify and fix any remaining issues with contrast, focus order, or element labeling.",
        "testStrategy": "Follow a scripted E2E test case for a new user registration and onboarding completion. Follow a second test case for an existing user login. Verify that in both scenarios, the AI prompts receive the correct context (or lack thereof for a user who just onboarded but hasn't used an AI feature yet). The goal is to validate the entire feature against the PRD's success metrics.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Fix Welcome Screen Navigation to Honor Onboarding Status",
        "description": "Correct the navigation from the welcome screen's 'Get Started' button. It currently bypasses the onboarding check and should instead route users to either the onboarding flow or the main dashboard based on their profile status.",
        "details": "The 'Get Started' button on the initial welcome screen is incorrectly hardcoded to navigate to the main application content. This needs to be updated to use the established onboarding logic. Refactor the `onPress` handler for the 'Get Started' button. It should read the user's profile from the global state store implemented in Task 7. Based on the presence of `brand_name` in the profile, use the Expo router to either `router.replace('/onboarding')` for new users or `router.replace('/dashboard')` for existing users, mirroring the logic from Task 5.",
        "testStrategy": "1. Log in as a new user with no brand information in their profile. Verify that tapping 'Get Started' on the welcome screen navigates you to the Brand Onboarding screen. 2. Log in as an existing user whose profile has a `brand_name`. Verify that tapping 'Get Started' on the welcome screen navigates you directly to the main dashboard, completely bypassing the onboarding screen. 3. Confirm this behavior is consistent on both iOS and Android platforms.",
        "status": "done",
        "dependencies": [
          3,
          5,
          7
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Integrate Onboarding Screen into Main Navigation Stack",
        "description": "Add the Brand Onboarding screen to the main authenticated navigation stack configuration. This makes the '/onboarding' route available to the application, enabling the conditional navigation logic.",
        "details": "Locate the primary layout file for the authenticated user routes, likely `app/(app)/_layout.js` or a similar file managing the main `Stack`. Within the `Stack` component, add a new `<Stack.Screen />` entry for the onboarding flow. Set the `name` prop to 'onboarding' to match the route used in the navigation logic from Task 5. Configure the screen options to provide a seamless onboarding experience by setting `headerShown: false`.",
        "testStrategy": "1. After implementation, run the application and log in as a new user (one without brand data). Verify that you are automatically redirected to and can see the Brand Onboarding screen, confirming the logic from Task 5 now works. 2. Log in as an existing user (with brand data). Verify that you are taken to the main dashboard, correctly bypassing the onboarding screen. 3. Manually verify that the rendered onboarding screen has no header, providing a full-screen view as intended.",
        "status": "done",
        "dependencies": [
          3,
          5
        ],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-09T16:23:26.007Z",
      "updated": "2025-07-09T16:55:01.305Z",
      "description": "Tasks for master context"
    }
  }
}